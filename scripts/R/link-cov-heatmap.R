#!/usr/bin/env Rscript --vanilla

# Plot coverage matrix generated by e.g. 'mccortex31 links --covg-hist out.csv ...'
#
args <- commandArgs(trailingOnly=TRUE)
if(length(args) != 2 && length(args) != 3 && length(args) != 6) {
  stop("Usage: ./link-cov-heatmap.R <covg.csv> <out.pdf> [<cutoff> [<k> <kcov> <readlen>]]\n")
}

cutoff=0
kmer=0
kcov=0
readlen=0

input_csv <- args[1]
output_pdf <- args[2]
if(length(args) >= 3) { cutoff <- as.numeric(args[3]) }
if(length(args) >= 4) { kmer <- as.numeric(args[4]) }
if(length(args) >= 5) { kcov <- as.numeric(args[5]) }
if(length(args) >= 6) { readlen <- as.numeric(args[6]) }

library('ggplot2')
library('reshape')
library('scales')
library('plyr')

cat("input_csv='",input_csv,"'\n",sep='')
cat("output_pdf='",output_pdf,"'\n",sep='')
cat('cutoff=',cutoff,'\n',sep='')
cat('kmer=',kmer,'\n',sep='')
cat('kcov=',kcov,'\n',sep='')
cat('readlen=',readlen,'\n',sep='')

# d = matrix(1:9,nrow=3,ncol=3)
# d.m <- melt(d, varnames=c("dist","cov"))

# file='proj/k31/links/ben.se.thresh.csv'
t <- read.table(input_csv,sep=',',head=T,row.names=1,comment.char='#')
r <- t
# Convert row/column names to numbers
colnames(r)=1:ncol(r)
rownames(r)=1:nrow(r)

maxcov=ncol(r)
maxdist=nrow(r)


# Normalise columns
norm <- function(x) {
  max = max(x); min = min(x); diff = max(x)-min(x)
  if(diff == 0) { return (x); }
  else { return((x-min) / diff); }
}

r.m <- t(apply(as.matrix(r), 1, norm))
d.m <- melt(r.m, varnames=c("dist","cov"))
d.m <- ddply(d.m, .(dist), transform)

get_step <- function(max) {
  s <- floor(max/100)*10
  if(s == 0) { return(1); }
  else { return(s); }
}

xstep<-get_step(maxdist)
xticks=seq(xstep,maxdist,xstep)
ystep<-get_step(maxcov)
yticks=seq(0,maxcov-1,ystep) # y starts from zero, -1 on scale

p <- ggplot(d.m, aes(dist, cov)) + theme(panel.background = element_rect(fill = 'white', colour = 'white')) +
     geom_tile(aes(fill = value), color = "white") +
     scale_fill_gradient(low = "white", high = "steelblue") +
     ggtitle("Link coverage") +
     scale_x_discrete(name="Distance (kmers)", breaks=rownames(r)[xticks], labels=xticks) +
     scale_y_discrete(name="Coverage", breaks=colnames(r)[yticks+1], labels=yticks)

if(cutoff > 0) {
  cutline <- data.frame(x=as.numeric(c(0,maxdist)),y=as.numeric(c(cutoff,cutoff)))
  p <- p + geom_line(data=cutline, aes(x=x,y=y), color="black")
}

if(kmer > 0 && kcov > 0 && readlen > 0) {
  # Plot expected coverage
  # kcov = cov * (readlen-k+1) / readlen
  cov = kcov * readlen / (readlen-kmer+1)
  x <- 1:maxdist
  y <- cov * (readlen - (kmer+x) + 1) / readlen;
  y[y<0] <- 0 # set negative values to zero
  expcov <- data.frame(x=as.numeric(x),y=as.numeric(y))
  p <- p + geom_line(data=expcov, aes(x=x, y=y), color="black", linetype="dashed")
}

ggsave(p, file=output_pdf, width=6, height=6)
